package ca.mcgill.ecse428.CourseChamp.model;

import java.util.*;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.ManyToOne;

/**
 * Class that is part of the domain model of the CourseChamp System
 * This class contains information related to course offerings
 * 
 * A major part of this class is auto-generated by umple
 * This class is also JPA anotated for ORM
 */
@Entity
public class CourseOffering {

  // ------------------------
  // MEMBER VARIABLES
  // ------------------------

  // CourseOffering Attributes
  @Id
  @GeneratedValue(strategy = GenerationType.AUTO)
  private int id;
  private String semester;

  // CourseOffering Associations
  @ManyToMany
  @JoinTable(name = "CourseOfferings_Professors", joinColumns = {
      @JoinColumn(name = "courseOfferingId") }, inverseJoinColumns = {
          @JoinColumn(name = "id") })
  private List<Professor> professors;
  @ManyToOne
  private Course course;

  // ------------------------
  // CONSTRUCTOR
  // ------------------------
  public CourseOffering() {
  }

  public CourseOffering(int aId, String aSemester, Course aCourse, Professor... allProfessors) {
    id = aId;
    semester = aSemester;
    professors = new ArrayList<Professor>();
    boolean didAddProfessors = setProfessors(allProfessors);
    if (!didAddProfessors) {
      throw new RuntimeException(
          "Unable to create CourseOffering, must have at least 1 professors. See http://manual.umple.org?RE002ViolationofAssociationMultiplicity.html");
    }
    if (!setCourse(aCourse)) {
      throw new RuntimeException(
          "Unable to create CourseOffering due to aCourse. See http://manual.umple.org?RE002ViolationofAssociationMultiplicity.html");
    }
  }

  // ------------------------
  // INTERFACE
  // ------------------------

  public boolean setId(int aId) {
    boolean wasSet = false;
    id = aId;
    wasSet = true;
    return wasSet;
  }

  public boolean setSemester(String aSemester) {
    boolean wasSet = false;
    semester = aSemester;
    wasSet = true;
    return wasSet;
  }

  public int getId() {
    return id;
  }

  public String getSemester() {
    return semester;
  }

  /* Code from template association_GetMany */
  public Professor getProfessor(int index) {
    Professor aProfessor = professors.get(index);
    return aProfessor;
  }

  public List<Professor> getProfessors() {
    List<Professor> newProfessors = Collections.unmodifiableList(professors);
    return newProfessors;
  }

  public int numberOfProfessors() {
    int number = professors.size();
    return number;
  }

  public boolean hasProfessors() {
    boolean has = professors.size() > 0;
    return has;
  }

  public int indexOfProfessor(Professor aProfessor) {
    int index = professors.indexOf(aProfessor);
    return index;
  }

  /* Code from template association_GetOne */
  public Course getCourse() {
    return course;
  }

  /* Code from template association_IsNumberOfValidMethod */
  public boolean isNumberOfProfessorsValid() {
    boolean isValid = numberOfProfessors() >= minimumNumberOfProfessors();
    return isValid;
  }

  /* Code from template association_MinimumNumberOfMethod */
  public static int minimumNumberOfProfessors() {
    return 1;
  }

  /* Code from template association_AddManyToManyMethod */
  public boolean addProfessor(Professor aProfessor) {
    boolean wasAdded = false;
    if (professors.contains(aProfessor)) {
      return false;
    }
    professors.add(aProfessor);
    if (aProfessor.indexOfCourseOffering(this) != -1) {
      wasAdded = true;
    } else {
      wasAdded = aProfessor.addCourseOffering(this);
      if (!wasAdded) {
        professors.remove(aProfessor);
      }
    }
    return wasAdded;
  }

  /* Code from template association_AddMStarToMany */
  public boolean removeProfessor(Professor aProfessor) {
    boolean wasRemoved = false;
    if (!professors.contains(aProfessor)) {
      return wasRemoved;
    }

    if (numberOfProfessors() <= minimumNumberOfProfessors()) {
      return wasRemoved;
    }

    int oldIndex = professors.indexOf(aProfessor);
    professors.remove(oldIndex);
    if (aProfessor.indexOfCourseOffering(this) == -1) {
      wasRemoved = true;
    } else {
      wasRemoved = aProfessor.removeCourseOffering(this);
      if (!wasRemoved) {
        professors.add(oldIndex, aProfessor);
      }
    }
    return wasRemoved;
  }

  /* Code from template association_SetMStarToMany */
  public boolean setProfessors(Professor... newProfessors) {
    boolean wasSet = false;
    ArrayList<Professor> verifiedProfessors = new ArrayList<Professor>();
    for (Professor aProfessor : newProfessors) {
      if (verifiedProfessors.contains(aProfessor)) {
        continue;
      }
      verifiedProfessors.add(aProfessor);
    }

    if (verifiedProfessors.size() != newProfessors.length || verifiedProfessors.size() < minimumNumberOfProfessors()) {
      return wasSet;
    }

    ArrayList<Professor> oldProfessors = new ArrayList<Professor>(professors);
    professors.clear();
    for (Professor aNewProfessor : verifiedProfessors) {
      professors.add(aNewProfessor);
      if (oldProfessors.contains(aNewProfessor)) {
        oldProfessors.remove(aNewProfessor);
      } else {
        aNewProfessor.addCourseOffering(this);
      }
    }

    for (Professor anOldProfessor : oldProfessors) {
      anOldProfessor.removeCourseOffering(this);
    }
    wasSet = true;
    return wasSet;
  }

  /* Code from template association_AddIndexControlFunctions */
  public boolean addProfessorAt(Professor aProfessor, int index) {
    boolean wasAdded = false;
    if (addProfessor(aProfessor)) {
      if (index < 0) {
        index = 0;
      }
      if (index > numberOfProfessors()) {
        index = numberOfProfessors() - 1;
      }
      professors.remove(aProfessor);
      professors.add(index, aProfessor);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveProfessorAt(Professor aProfessor, int index) {
    boolean wasAdded = false;
    if (professors.contains(aProfessor)) {
      if (index < 0) {
        index = 0;
      }
      if (index > numberOfProfessors()) {
        index = numberOfProfessors() - 1;
      }
      professors.remove(aProfessor);
      professors.add(index, aProfessor);
      wasAdded = true;
    } else {
      wasAdded = addProfessorAt(aProfessor, index);
    }
    return wasAdded;
  }

  /* Code from template association_SetUnidirectionalOne */
  public boolean setCourse(Course aNewCourse) {
    boolean wasSet = false;
    if (aNewCourse != null) {
      course = aNewCourse;
      wasSet = true;
    }
    return wasSet;
  }

  public void delete() {
    ArrayList<Professor> copyOfProfessors = new ArrayList<Professor>(professors);
    professors.clear();
    for (Professor aProfessor : copyOfProfessors) {
      aProfessor.removeCourseOffering(this);
    }
    course = null;
  }

  public String toString() {
    return super.toString() + "[" +
        "id" + ":" + getId() + "," +
        "semester" + ":" + getSemester() + "]" + System.getProperties().getProperty("line.separator") +
        "  " + "course = " + (getCourse() != null ? Integer.toHexString(System.identityHashCode(getCourse())) : "null");
  }
}